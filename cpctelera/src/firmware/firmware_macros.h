//-----------------------------LICENSE NOTICE------------------------------------
//  This file is part of CPCtelera: An Amstrad CPC Game Engine
//  Copyright (C) 2021 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
//  Copyright (C) 2021 Nestornillo (https://github.com/nestornillo)
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//------------------------------------------------------------------------------

#ifndef _CPCT_FIRMWARE_MACROS_H
#define _CPCT_FIRMWARE_MACROS_H

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
// File: Macros (C)
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// Group: Firmware macros
////////////////////////////////////////////////////////////////////////

//
// Macro: cpctm_createInterruptHandlerWrapper
//
//    Macro that creates a custom interrupt handler wrapper function.
//
// C Definition:
//   #define <cpctm_createInterruptHandlerWrapper> (*WRAPPERNAME*, *INTHANDLER*,
// *R1*, *R2*, *R3*, *R4*, *R5*, *R6*, *R7*, *R8*, *R9*, *R10*, *R11*)
//
// Parameters:
// WRAPPERNAME - C-identifier to be used as name for the generated wrapper function.
// INTHANDLER - C-identifier of the interrupt handler function that will be wrapped
// R1-R11 - List of registers to be saved (*af*, *bc*, *de*, *hl*, *ix*, *iy*,
// or *alt* for choosing alternate registers)
//
// Details:
//   This macro generates a wrapper function to safely call user provided
// *intHandler*. This code saves on the stack the registers that are specified
// in the parameters of the macro. The selected registers are restored after
// user code from *intHandler* finishes. Therefore, user does not have to worry
// about saving and restoring registers during interrupts. However, when using
// this macro, user is responsible for choosing which registers are saved. Be
// aware that in most cases all standard registers (AF BC DE HL IX IY) should be
// preserved.
//
//   First parameter of the macro calling is the name that will be assigned to
// the resulting wrapper function.
//
//   Second parameter is the C-identifier of the interrupt handler function that
// will be wrapped with the code generated by this macro.
//
//   Next optional parameters are the registers that will be preserved in the
// resulting code. We can use symbols *af*, *bc*, *de*, *hl*, *ix* and *iy* to
// indicate which standard registers should be saved. After standard registers
// we can use symbol *alt* to indicate that following parameters refer to
// alternate registers, which can be specified with symbols *af*, *bc*, *de*,
// and *hl*.
//
//   As opposed to <cpct_setInterruptHandler>, the code generated by this macro
// does not modify the interrupt vector to establish the resulting function as a
// new interrupt handler. That can be done using <cpct_setInterruptHandler_naked>.
//
// Examples of use:
//   For next examples we'll suppose that *myIntHandler* is an interrupt handler
// function defined by the user.
// * Saving standard registers
// (start code)
// cpctm_createInterruptHandlerWrapper(StandardRegsWrapper, myIntHandler, af, bc, de, hl, ix, iy);
// (end code)
// Previous line will create a function named *StandardRegsWrapper*. This function
// will save standard registers (AF, BC, DE, HL, IX, IY) before calling the
// interrupt handler function *intHandler*. When *intHandler* returns,
// *StandardRegsWrapper* will restore the saved registers before exiting the interrupt.
// In order to use the generated routine, we can use <cpct_setInterruptHandler_naked>
// to patch the interrupt vector.
// (start code)
// cpct_setInterruptHandler_naked(StandardRegsWrapper);
// (end code)
// If we want to use our generated function in a C file different from the one
// with the macro calling, first weâ€™ll need to declare it using
// <cpctm_declareInterruptHandlerWrapper> macro, as shown in next example.
// (start code)
// cpctm_declareInterruptHandlerWrapper(StandardRegsWrapper);
// // ...
// void init(void) {
//  // ...
//  cpct_setInterruptHandler_naked(StandardRegsWrapper);
// }
// (end code)
// * Saving all registers
//
//   Next line will create *AllRegsWrapper* function. This created function
// will preserve all standard and alternate registers in the interrupt handler calling.
// (start code)
// cpctm_createInterruptHandlerWrapper(AllRegsWrapper, myIntHandler, af, bc, de, hl, ix, iy, alt, af, bc, de, hl);
// (end code)
// * Saving no registers
//
//   If you don't need to preserve any register you can use the next calling. Be
// aware that in most cases you will need to preserve at least the standard registers.
// (start code)
// cpctm_createInterruptHandlerWrapper(NoRegsWrapper, myIntHandler);
// (end code)
// * Saving standard registers + AF' + HL'
//
//   As another example, next line creates a custom interrupt handler wrapper that
// preserves standard registers (AF BC DE HL IX IY) and also preserves AF' and HL'.
// (start code)
// cpctm_createInterruptHandlerWrapper(MyWrapper, myIntHandler, af, bc, de, hl, ix, iy, alt, af, hl);
// (end code)
//
// Known issues:
//   * This macro can only be used from C code. It is not accessible from assembler
// scope. For assembler programs, please refer to <cpctm_createInterruptHandlerWrapper_asm>
// assembler macro. However, the resulting code of this macro can be used from
// assembler scope.
//   * This macro will work *only* with constant values, as its value needs to
// be calculated in compilation time. If fed with variable values, it will give
// an assembler error.
//
// Size of generated code:
//    Depending on which registers you choose to preserve the resulting code will
// vary its size. Next are some values as a reference.
// (start code)
// Case                     | Size
// ------------------------------------
// No registers saved       |  7 bytes
// Standard registers saved | 23 bytes
// All registers saved      | 35 bytes
// ------------------------------------
// (end code)
//
// Time Measures:
//  * This measure is the time overhead required for safely calling user defined
// function. That is, time required by the generated wrapper function to save
// registers, call user's *intHandler*, restoring the registers and returning.
// This overhead is to be assumed each time interrupt handler is called, so up
// to 6 times per frame, 300 times per second. Depending on which registers you
// choose to be saved, the resulting function will take different time to
// complete. Next measures show some possible cases.
// (start code)
// Case                     | microSecs (us) | CPU Cycles
// -------------------------------------------------------
// No registers saved       |      11        |     44
// Standard registers saved |      57        |    228
// All registers saved      |      89        |    356
// -------------------------------------------------------
// (end code)
//

#define  cpctm_createInterruptHandlerWrapper(WrapperName,...) \
  void WrapperName()  __naked { \
     __asm \
     .mdelete cpct_checkReg_ \
     .macro cpct_checkReg_ \
     .endm \
     .mdelete cpct_checkReg_alt \
     .macro cpct_checkReg_alt \
       .equ cpct_altDetected, 1 \
     .endm \
     .mdelete cpct_checkReg_af \
     .macro cpct_checkReg_af \
       .if cpct_altDetected \
         .equ cpct_altAFdetected, 1 \
       .endif \
     .endm \
     .mdelete cpct_checkReg_bc \
     .macro cpct_checkReg_bc \
       .if cpct_altDetected \
         .equ cpct_altBCDEHLdetected, 1 \
       .endif \
     .endm \
     .mdelete cpct_checkReg_de \
     .macro cpct_checkReg_de \
       .if cpct_altDetected \
         .equ cpct_altBCDEHLdetected, 1 \
       .endif \
     .endm \
     .mdelete cpct_checkReg_hl \
     .macro cpct_checkReg_hl \
       .if cpct_altDetected \
         .equ cpct_altBCDEHLdetected, 1 \
       .endif \
     .endm \
     .mdelete cpct_checkReg_ix \
     .macro cpct_checkReg_ix \
     .endm \
     .mdelete cpct_checkReg_iy \
     .macro cpct_checkReg_iy \
     .endm \
     .mdelete cpct_saveReg_ \
     .macro cpct_saveReg_ \
     .endm \
     .mdelete cpct_saveReg_alt \
     .macro cpct_saveReg_alt \
        .if cpct_altAFdetected \
          .db 8 \
        .endif \
        .if cpct_altBCDEHLdetected \
          exx \
        .endif \
     .endm \
     .mdelete cpct_saveReg_af \
     .macro cpct_saveReg_af \
        push af \
     .endm \
     .mdelete cpct_saveReg_bc \
     .macro cpct_saveReg_bc \
        push bc \
     .endm \
     .mdelete cpct_saveReg_de \
     .macro cpct_saveReg_de \
        push de \
     .endm \
     .mdelete cpct_saveReg_hl \
     .macro cpct_saveReg_hl \
        push hl \
     .endm \
     .mdelete cpct_saveReg_ix \
     .macro cpct_saveReg_ix \
        push ix \
     .endm \
     .mdelete cpct_saveReg_iy \
     .macro cpct_saveReg_iy \
        push iy \
     .endm \
     .mdelete cpct_restoreReg_ \
     .macro cpct_restoreReg_ \
     .endm \
     .mdelete cpct_restoreReg_alt \
     .macro cpct_restoreReg_alt \
       .if cpct_altBCDEHLdetected \
         exx \
       .endif \
       .if cpct_altAFdetected \
         .db 8 \
       .endif \
     .endm \
     .mdelete cpct_restoreReg_af \
     .macro cpct_restoreReg_af \
        pop af \
     .endm \
     .mdelete cpct_restoreReg_bc \
     .macro cpct_restoreReg_bc \
        pop bc \
     .endm \
     .mdelete cpct_restoreReg_de \
     .macro cpct_restoreReg_de \
        pop de \
     .endm \
     .mdelete cpct_restoreReg_hl \
     .macro cpct_restoreReg_hl \
        pop hl \
     .endm \
     .mdelete cpct_restoreReg_ix \
     .macro cpct_restoreReg_ix \
        pop ix \
     .endm \
     .mdelete cpct_restoreReg_iy \
     .macro cpct_restoreReg_iy \
        pop iy \
     .endm \
     .mdelete cpct_createIntWrapperCmacro \
     .macro cpct_createIntWrapperCmacro userHandlerFunction, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11 \
       .equ cpct_altAFdetected, 0 \
       .equ cpct_altBCDEHLdetected, 0 \
       .equ cpct_altDetected, 0 \
       __endasm; \
       __asm__("cpct_checkReg_'R1"); \
       __asm__("cpct_checkReg_'R2"); \
       __asm__("cpct_checkReg_'R3"); \
       __asm__("cpct_checkReg_'R4"); \
       __asm__("cpct_checkReg_'R5"); \
       __asm__("cpct_checkReg_'R6"); \
       __asm__("cpct_checkReg_'R7"); \
       __asm__("cpct_checkReg_'R8"); \
       __asm__("cpct_checkReg_'R9"); \
       __asm__("cpct_checkReg_'R10"); \
       __asm__("cpct_checkReg_'R11"); \
       __asm__("cpct_saveReg_'R1"); \
       __asm__("cpct_saveReg_'R2"); \
       __asm__("cpct_saveReg_'R3"); \
       __asm__("cpct_saveReg_'R4"); \
       __asm__("cpct_saveReg_'R5"); \
       __asm__("cpct_saveReg_'R6"); \
       __asm__("cpct_saveReg_'R7"); \
       __asm__("cpct_saveReg_'R8"); \
       __asm__("cpct_saveReg_'R9"); \
       __asm__("cpct_saveReg_'R10"); \
       __asm__("cpct_saveReg_'R11"); \
       __asm__("call _'userHandlerFunction"); \
       __asm__("cpct_restoreReg_'R11"); \
       __asm__("cpct_restoreReg_'R10"); \
       __asm__("cpct_restoreReg_'R9"); \
       __asm__("cpct_restoreReg_'R8"); \
       __asm__("cpct_restoreReg_'R7"); \
       __asm__("cpct_restoreReg_'R6"); \
       __asm__("cpct_restoreReg_'R5"); \
       __asm__("cpct_restoreReg_'R4"); \
       __asm__("cpct_restoreReg_'R3"); \
       __asm__("cpct_restoreReg_'R2"); \
       __asm__("cpct_restoreReg_'R1"); \
       __asm \
     .endm \
     WrapperName:: \
     di \
     cpct_createIntWrapperCmacro __VA_ARGS__ \
     ei \
     reti \
     __endasm; \
  } \
  extern void WrapperName (void) __naked


//
// Macro: cpctm_declareInterruptHandlerWrapper
//
//    Declares a custom interrupt handler wrapper funtion created with
// <cpctm_createInterruptHandlerWrapper> or <cpctm_createInterruptHandlerWrapper_asm>.
// It does not create the wrapper code: it only declares it to make it accessible
// from different code files.
//
// C Definition:
//    #define <cpctm_declareInterruptHandlerWrapper> (*WRAPPERNAME*)
//
// Parameters:
//    WRAPPERNAME - C-identifier used for creation of the interrupt handler wrapper
//
// Details:
//    This macro generates a declaration for a custom interrupt handler wrapper
// funtion created with the given *WRAPPERNAME* name using
// <cpctm_createInterruptHandlerWrapper> (or <cpctm_createInterruptHandlerWrapper_asm>).
// The interrupt handler wrapper is declared as *extern* and will require to be
// defined in a source code file. If an interrupt handler wrappper is declared
// using this macro but not defined using <cpctm_createInterruptHandlerWrapper>,
// a linker error will happen.
//
// Use example:
//    Imagine we have 3 source files and 1 header file: a.c, b.c, i.c and h.h.
// Both a.c and b.c make use of an interrupt handler wrapper function named
// AllRegsWrapper, which is defined in i.c. For that to be possible, we declare
// the function in h.h this way:
// (start code)
//    // Include functions
//    #ifndef _H_H_
//    #define _H_H_
//    #include <cpctelera.h>
//
//    // Declare AllRegsWrapper, which is defined in i.c, and used in a.c and in b.c also.
//    cpctm_declareInterruptHandlerWrapper(AllRegsWrapper);
//
//    #endif
// (end code)
//    With this declaration, a.c and b.c only have to include h.h to be able to access
// AllRegsWrapper, which is defined in i.c this way:
// (start code)
//    #include <cpctelera.h>
//    void intHandler (void){
//      // ...
//    }
//    cpctm_createInterruptHandlerWrapper(AllRegsWrapper, intHandler, af, bc, de, hl, ix, iy, alt, af, bc, de, hl);
// (end code)
//    Then, for instance, a.c. can make use of the function like in this example:
// (start code)
//    #include "h.h"
//    //.... code ....
//
//    // Set AllRegsWrapper as the new interrupt handler function, which will save
//    // all registers before calling intHandler
//    cpct_setInterruptHandler_naked(AllRegsWrapper);
// (end code)
//

#define cpctm_declareInterruptHandlerWrapper(customIHWName) \
extern void customIHWName (void)__naked


 #endif
